<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>lol</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview-architecture.html"><strong aria-hidden="true">1.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="log-snapshot.html"><strong aria-hidden="true">1.1.</strong> Log and Snapshot</a></li><li class="chapter-item expanded "><a href="snapshot-repository.html"><strong aria-hidden="true">1.2.</strong> Snapshot Repository</a></li><li class="chapter-item expanded "><a href="snapshot-types.html"><strong aria-hidden="true">1.3.</strong> Snapshot Types (Copy and Fold)</a></li><li class="chapter-item expanded "><a href="log-abstraction.html"><strong aria-hidden="true">1.4.</strong> Log Abstraction</a></li></ol></li><li class="chapter-item expanded "><a href="client-interactions.html"><strong aria-hidden="true">2.</strong> Client Interactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query-processing.html"><strong aria-hidden="true">2.1.</strong> Optimized Query Processing</a></li><li class="chapter-item expanded "><a href="gateway.html"><strong aria-hidden="true">2.2.</strong> Gateway</a></li></ol></li><li class="chapter-item expanded "><a href="cluster-management.html"><strong aria-hidden="true">3.</strong> Cluster Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="membership-change.html"><strong aria-hidden="true">3.1.</strong> Single-server changes</a></li></ol></li><li class="chapter-item expanded "><a href="election.html"><strong aria-hidden="true">4.</strong> Leader Election</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="failure-detection.html"><strong aria-hidden="true">4.1.</strong> Leader Failure Detection</a></li><li class="chapter-item expanded "><a href="timeout-now.html"><strong aria-hidden="true">4.2.</strong> Leadership Transfer Extension</a></li></ol></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">5.</strong> Tools</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">6.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">lol</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview-of-the-architecture" id="overview-of-the-architecture">Overview of the architecture</a></h1>
<p>This chapter describes the overview of the architecture.</p>
<p><img src="images/overview.png" alt="" /></p>
<p><code>RaftCore</code> is the heart of the Raft system. It includes internal states and functions that typically produces side effects.</p>
<p>Around the <code>RaftCore</code>, there are many companion threads that indefinitely loops and sends messages to <code>RaftCore</code>.</p>
<p>How much threads are there? As of 0.7, there are 7 threads around the core. This architecure is much like typical operating system that daemon threads are orbiting around the kernel.</p>
<p>The last element of the system is <code>RaftApp</code>. 
As its name suggests, it is a user application which runs on the <code>RaftCore</code>. The responsibility of the <code>RaftApp</code> is said to be only two things:</p>
<ol>
<li>Apply the messages to the state machine.</li>
<li>Make a new snapshot.</li>
</ol>
<p>By connecting your <code>RaftApp</code> with <code>RaftCore</code>, you can build your own Raft process that interacts with other Raft processes to form a Raft cluster of your own.</p>
<p>If you are ready to implement your own <code>RaftApp</code>, API doc and the KVS implementation under <code>example/kvs/</code> would help.</p>
<h1><a class="header" href="#log-and-snapshot" id="log-and-snapshot">Log and Snapshot</a></h1>
<p>To explain how I've designed the log and the snapshot in this library,
tracking the evolution of the design would be the quickest.</p>
<h2><a class="header" href="#v1-snapshot-as-a-log-entry" id="v1-snapshot-as-a-log-entry">v1: Snapshot as a log entry</a></h2>
<p>lol has started as a company project and it's aim is to 
replicate data in the same order in the cluster then we considered Raft would fit.
That was when my journey began.
The name &quot;lol&quot; comes from our project. (one of the two l means log but the another is secret)
Hornestly, it is not a joke.</p>
<p>Since our aim is to replicate the log, the log centric design is natural for me to start with.
Also, I don't like to implement InstallSnapshot RPC as described in Raft dissertation
because it would certainly introduce extra complexity to the software.</p>
<p>This way, the design v1 is drawn.</p>
<p><img src="images/log-v1.png" alt="" /></p>
<p>In this design, everything is a log entry. Everything includes not only the 
user command but snapshot and special entries to change the membership.
Log entry has a pair of term and index to the previous entry so to ensure the log consistency,
and the command payload in bytes for versatility.
Since everything is a log entry, everything in done under Raft's log replication mechanism.
This is so simple and easy to implement. But in terms of versatility, this design choice is not the optimimal.</p>
<p>Why is it not optimal? The main reason is the snapshot's size is limited by the
system memory since in replication
we must put in buffer to read or write the data
(Consider Put method in RocksDB).
We could avoid this by some implementation hacks like cutting snapshot payload into streaming chunks
but this would destroy the interfaces and not beatiful. Then we have to find a new design.</p>
<h2><a class="header" href="#v2-snapshot-inventory" id="v2-snapshot-inventory">v2: Snapshot Inventory</a></h2>
<p>The problem must root in the fact that we try to deal with completely different things, snapshot and normal entries, in the same way. That made me come up with the idea of <strong>snapshot inventory</strong>.</p>
<p>In Raft dissertation, InstallSnapshot RPC is PUSH operation because it is initiated in leader node and the snapshot chunks are sent in streaming to followers.</p>
<p>My idea is <em>completely the opposite</em>: <code>GetSnapshot</code> RPC is initiated by follower and leader sends back the snapshot in streaming after finding it in the snapshot inventory. This is a PULL operation.</p>
<p><img src="images/log-v2.png" alt="" /></p>
<p>In design v2, application snapshot is moved out of the snapshot entry and then put in snapshot inventory. The snapshot entry still exists and replicated to slow followers in the same way as in v1. The difference is: when follower received snapshot entry, it calls <code>GetSnapshot</code> RPC to the sender (in this case it must be a leader) to request the application snapshot in stream. When the <code>GetSnapshot</code> RPC is completed and the snapshot is stored in the snapshot inventory of its own, the follower node commits the snapshot entry just like the way filesystem firstly stores the file data and then metadata to complete the operation.</p>
<p>The greatest point of this algorithm is that leader node doesn't have to find slow nodes but slow node is noticed in the way of log replication. This makes the implemetation pretty simple and thus bug-free.</p>
<h1><a class="header" href="#snapshot-repository" id="snapshot-repository">Snapshot Repository</a></h1>
<p>In the previous section, we have learned that the snapshot is placed in somewhere outside the log entry and copied to other nodes in streaming.</p>
<p>The snapshot entity that is made from the stream and sent in stream is called <strong>snapshot resource</strong>.</p>
<p>The library does't care what it actually is and where it is actually placed but let's call it <strong>snapshot repository</strong>.</p>
<p><img src="images/snapshot-repository.png" alt="" /></p>
<p>In <code>RaftApp</code>'s <code>process_write</code>, you can create a new snapshot resource and save it in the snapshot repository.
The function then return <code>MakeSnapshot::CopySnapshot</code> to tell the <code>RaftCore</code> that a new snapshot is made.
If <code>RaftCore</code> is told that a new snapshot is made it tries to commit a snapshot entry corresponding to it.</p>
<p>Again, the library doesn't care what the snapshot resource actually is.
It can be a file in an object storage or a snapshot of some storage backend like RocksDB.
It is fully up to the implementor.</p>
<h1><a class="header" href="#snapshot-types-copy-and-fold" id="snapshot-types-copy-and-fold">Snapshot Types (Copy and Fold)</a></h1>
<p>The most difficult part of Raft implementation is how to deal with the snapshot. If you are a Raft library implementator like me, you will agree with this.</p>
<p>From the word &quot;snapshot&quot; you may imagine it is a copy (or light-weight snapshot) of the state machine which is provided by <code>RaftApp</code>. Yes, lol calls this type of snapshotting <strong>Copy snapshot</strong>. When <code>RaftApp</code> returns a Copy snapshot from <code>process_write</code> this snapshot is granted as a snapshot up to the current apply index.</p>
<p>From a different point of view, snapshot can be seen as recomputing the log entries up to some point in time. lol call this type of snapshot <strong>Fold snapshot</strong>.</p>
<p>lol supports both types of snapshot: Copy snapshot and Fold snapshot.</p>
<p>The comparison between these two is copy cost + overhead VS recomputation cost: Copy snapshot needs to copy the current snapshot in <code>process_write</code> so copy cost is charged (RocksDB or <a href="https://www.kernel.org/doc/Documentation/device-mapper/thin-provisioning.txt">dm-thin</a>'s snapshot is not even zero-cost) and the operation spends extra time. Fold snapshot on the other hands, can be executed in parallel with <code>process_write</code> but costs from recomputation.</p>
<h1><a class="header" href="#log-abstraction" id="log-abstraction">Log Abstraction</a></h1>
<p><code>RaftStorage</code> is the abstraction of the log storage.
Conceptually, it includes the recent vote and the log entries. Every snapshot entry is guaranteed to be have the corresponding snapshot resource because they are always committed after saving the corresponding resource.</p>
<p>By default, lol provides some implementations (memory, file and rocksdb). Normally, you can choose the best implementation from these three.</p>
<p>Some other Raft libraries like async-raft defines one huge abstraction that kind of mixes RaftApp and RaftStorage but I went the different way because these two can be cleanly separated in my architecture and it is more user-friendly because only thing user needs to implement is <code>RaftApp</code>.</p>
<h1><a class="header" href="#client-interactions" id="client-interactions">Client Interactions</a></h1>
<p>In Raft, any command is sent to the leader and later the command is processed by the state machine. That is a textbook explanation of Raft protocol.</p>
<p>However, this needs to send the request to the leader (lol implements forwarding so user request sent to any of the servers are forwarded to the leader), the command is replicated to the majority of servers, wait for application to state machine and finally acks. This takes much time.</p>
<p>Some command may need all these processings before ack but other may not. For example, some command may be allowed to ack before entry application as it is guaranteed to be applied in some time later.</p>
<p>lol allows clients to interact with the cluster in a variety of ways. Here is the list:</p>
<ul>
<li><strong>RequestApply</strong>: The command is sent to the leader, appended to log, replicated to majority, applied and then ack.</li>
<li><strong>RequestCommit</strong>: The command is sent to the leader, appended to log, replicated to majority and then ack.</li>
</ul>
<h1><a class="header" href="#optimized-query-processing" id="optimized-query-processing">Optimized Query Processing</a></h1>
<p>In normal Raft, any application commands are appended to log and brought to the state machine to be applied. However, if the command is query type which doesn't have any side effects, there is a possible optimization.</p>
<p>In <code>RequestApply</code>, if the request's <code>mutation</code> is false then the request is recognized as query. As described in $6.4 of Raft dissertation, the query waits for the <code>read_index</code> (the <code>commit_index</code> at the moment the query hits the server) to be applied.</p>
<p>In the implementation, queries are firstly put into <code>QueryQueue</code> and processed later.
The processings are done in parallel if there are more than one queries waiting for the same <code>read_index</code> to complete.</p>
<h1><a class="header" href="#gateway" id="gateway">Gateway</a></h1>
<p>In Raft, client request is sent to the leader and processed by the leader. So how did the client know who is the leader?</p>
<p>In Raft dissertation, some algorithm are described. One of which is sending back known leader as a hint when client sent the request to some non-leader node. Forwarding the request to the leader is also explained.</p>
<p>But how do you access the follower? More precisely, how do you know some valid node in the current membership?</p>
<p>lol's <code>Gateway</code> tracks the current membership by polling the membership so client is always accessible to at least one node in the cluster. After giving some valid members to the <code>Gateway</code> manually, <code>Gateway</code> automatically tracks the cluster until it is destructed.</p>
<p><img src="images/gateway.png" alt="" /></p>
<h1><a class="header" href="#cluster-management" id="cluster-management">Cluster Management</a></h1>
<p>In lol, adding and removing a server to and from the cluster is just an extension of normal log replication. This means the cluster must have a leader to accept spacial requests: <code>AddServer</code> and <code>RemoveServer</code> which leads to append a special command called <code>ClusterConfiguration</code>.</p>
<p>When you start a single Raft server, you may think the node automatically forms a small cluster with one node and becomes a leader but this is a wrong assumption because starting a second server will cause <strong>split brain</strong> because there are two leaders at the same time. This is what Raft's election algorithm tries to avoid by choosing only one leader in a single term.</p>
<p>You now learned that starting a server does not automatically form a cluster nor give it a leadership. However, this leads to an other problem: How to add servers? Since there is no leader to accept <code>AddServer</code> request.</p>
<p>In lol, When a server received <code>AddServer</code> request and it doesn't belong to any cluster, it forms a cluster with only itself, regardless of the leadership. This is called <strong>cluster bootstrapping</strong>.</p>
<p><img src="images/cluster-management.png" alt="" /></p>
<h1><a class="header" href="#single-server-changes" id="single-server-changes">Single-server changes</a></h1>
<p>There are two methods to change the cluster membership in Raft: one is by joint concensus algorithm and the another is single-server changes.</p>
<p>In the initial Raft research paper, joint consensus algorithm was used to change the membership but later the author found a flaw in joint consensus algorithm, and the lastest dissertation uses single-server changes. lol uses this.</p>
<p>So what is single-server changes? This algorithm adds or removes only one server at a time.</p>
<p>These operations are represented as special requests (<code>AddServer</code> and <code>RemoveServer</code>) and it turns into <code>ClusterConfiguration</code> command in the log which is then replicated to the cluster as well as normal commands.</p>
<p>The rational behind this is a single-server change always share the majority nodes between before and after the change.
The following figure from Raft dissertation describes a case of adding one node.</p>
<p><img src="images/single-server-changes.png" alt="" /></p>
<p>So the next leader always know the latest membership and the consensus on membership change will never be lost.</p>
<h1><a class="header" href="#leader-election" id="leader-election">Leader Election</a></h1>
<p>In Raft, leader has a special authority in the cluster.</p>
<p>The algorithm proves only one leader exists in one term and the leader is at least
&quot;stronger&quot; (I have no idea about better expression) than the majority of the cluster servers.
The principle is very simple however, there are non-trivial corner cases and some useful extensions.</p>
<h1><a class="header" href="#leader-failure-detection" id="leader-failure-detection">Leader failure detection</a></h1>
<p>Typical Raft implementation uses static election timeout to detect leader failure however, this strongly assumes that latency between nodes is uniform and measurable in prior of deployment. The assumption is broken when you go out to cloud.</p>
<p>To solve this, lol uses <strong>adaptive failure detection</strong> algorithm called Phi-Accurual detection algorithm. The concept is very simple: the history of heartbeats is given and assume the intervals are distributed normally then we are able to calculate the possiblity of getting another heartbeat in the future.</p>
<p>With this feature, applications based on lol can be deployed in cloud where the latency between nodes may be difference and unstable.</p>
<h1><a class="header" href="#leadership-transfer-extension" id="leadership-transfer-extension">Leadership Transfer Extension</a></h1>
<p>In Raft, leader is chosen by election.
Election happens when follower considers leader is dead.</p>
<p>If leader is removed from the cluster, every client requests
fails until a new leader is elected.</p>
<p>To avoid this, lol implements <code>TimeoutNow</code> RPC which requests a node to
immediately start election (by becoming candidate in new term) regardless of election timeout.</p>
<p>In lol, when leader is removed from the cluster, this <code>TimeoutNow</code> RPC is sent to 
one of the living nodes so a new leader is immediately chosen.</p>
<p>This RPC is also used to pin the leader node.
In some senario, some node is more suitable for being a leader than other nodes.</p>
<h1><a class="header" href="#tools" id="tools">Tools</a></h1>
<ul>
<li><a href="https://github.com/akiradeveloper/lol/tree/master/lol-admin">lol-admin</a>: Command line tool for admin.</li>
</ul>
<h1><a class="header" href="#references" id="references">References</a></h1>
<ul>
<li><a href="https://github.com/ongardie/dissertation">Raft Dissertation</a>: Diego Ongaro's Dissertation in Stanford Univ.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
